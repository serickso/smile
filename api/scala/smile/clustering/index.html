<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>Smile - Statistical Machine Intelligence and Learning Engine  - smile.clustering</title>
          <meta name="description" content="Smile - Statistical Machine Intelligence and Learning Engine - smile.clustering" />
          <meta name="keywords" content="Smile Statistical Machine Intelligence and Learning Engine smile.clustering" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../lib/index.js"></script>
      <script type="text/javascript" src="../../index.js"></script>
      <script type="text/javascript" src="../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">Smile - Statistical Machine Intelligence and Learning Engine<span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="High level Smile operators in Scala." href="../../index.html">
              <span class="name">root</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">High level Smile operators in Scala.</p><div class="fullcomment"><div class="comment cmt"><p>High level Smile operators in Scala.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.smile" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="smile"></a><a id="smile:smile"></a>
      <span class="permalink">
      <a href="index.html#smile" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html">
              <span class="name">smile</span>
            </a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="smile.association" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="association"></a><a id="association:association"></a>
      <span class="permalink">
      <a href="../smile/index.html#association" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Frequent item set mining and association rule mining." href="../association/index.html">
              <span class="name">association</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Frequent item set mining and association rule mining.</p><div class="fullcomment"><div class="comment cmt"><p>Frequent item set mining and association rule mining.
Association rule learning is a popular and well researched method for
discovering interesting relations between variables in large databases.
Let I = {i<sub>1</sub>, i<sub>2</sub>,..., i<sub>n</sub>} be a set of n
binary attributes called items. Let D = {t<sub>1</sub>, t<sub>2</sub>,..., t<sub>m</sub>}
be a set of transactions called the database. Each transaction in D has a
unique transaction ID and contains a subset of the items in I.
An association rule is defined as an implication of the form X &rArr; Y
where X, Y &sube; I and X &cap; Y = &Oslash;. The item sets X and Y are called
antecedent (left-hand-side or LHS) and consequent (right-hand-side or RHS)
of the rule, respectively. The support supp(X) of an item set X is defined as
the proportion of transactions in the database which contain the item set.
Note that the support of an association rule X &rArr; Y is supp(X &cup; Y).
The confidence of a rule is defined conf(X &rArr; Y) = supp(X &cup; Y) / supp(X).
Confidence can be interpreted as an estimate of the probability P(Y | X),
the probability of finding the RHS of the rule in transactions under the
condition that these transactions also contain the LHS.</p><p>For example, the rule {onions, potatoes} &rArr; {burger} found in the sales
data of a supermarket would indicate that if a customer buys onions and
potatoes together, he or she is likely to also buy burger. Such information
can be used as the basis for decisions about marketing activities such as
promotional pricing or product placements.</p><p>Association rules are usually required to satisfy a user-specified minimum
support and a user-specified minimum confidence at the same time. Association
rule generation is usually split up into two separate steps:</p><ul><li>First, minimum support is applied to find all frequent item sets
   in a database (i.e. frequent item set mining).</li><li>Second, these frequent item sets and the minimum confidence constraint
   are used to form rules.</li></ul><p>Finding all frequent item sets in a database is difficult since it involves
searching all possible item sets (item combinations). The set of possible
item sets is the power set over I (the set of items) and has size 2<sup>n</sup> - 1
(excluding the empty set which is not a valid item set). Although the size
of the power set grows exponentially in the number of items n in I, efficient
search is possible using the downward-closure property of support
(also called anti-monotonicity) which guarantees that for a frequent item set
also all its subsets are frequent and thus for an infrequent item set, all
its supersets must be infrequent.</p><p>In practice, we may only consider the frequent item set that has the maximum
number of items bypassing all the sub item sets. An item set is maximal
frequent if none of its immediate supersets is frequent.</p><p>For a maximal frequent item set, even though we know that all the sub item
sets are frequent, we don't know the actual support of those sub item sets,
which are very important to find the association rules within the item sets.
If the final goal is association rule mining, we would like to discover
closed frequent item sets. An item set is closed if none of its immediate
supersets has the same support as the item set.</p><p>Some well known algorithms of frequent item set mining are Apriori,
Eclat and FP-Growth. Apriori is the best-known algorithm to mine association
rules. It uses a breadth-first search strategy to counting the support of
item sets and uses a candidate generation function which exploits the downward
closure property of support. Eclat is a depth-first search algorithm using
set intersection.</p><p>FP-growth (frequent pattern growth) uses an extended prefix-tree (FP-tree)
structure to store the database in a compressed form. FP-growth adopts a
divide-and-conquer approach to decompose both the mining tasks and the
databases. It uses a pattern fragment growth method to avoid the costly
process of candidate generation and testing used by Apriori.</p><h6>References:</h6><ul><li>R. Agrawal, T. Imielinski and A. Swami. Mining Association Rules Between Sets of Items in Large Databases, SIGMOD, 207-216, 1993.</li><li>Rakesh Agrawal and Ramakrishnan Srikant. Fast algorithms for mining association rules in large databases. VLDB, 487-499, 1994.</li><li>Mohammed J. Zaki. Scalable algorithms for association mining. IEEE Transactions on Knowledge and Data Engineering, 12(3):372-390, 2000.</li><li>Jiawei Han, Jian Pei, Yiwen Yin, and Runying Mao. Mining frequent patterns without candidate generation. Data Mining and Knowledge Discovery 8:53-87, 2004.
</li></ul></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.classification" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="classification"></a><a id="classification:classification"></a>
      <span class="permalink">
      <a href="../smile/index.html#classification" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Classification algorithms." href="../classification/index.html">
              <span class="name">classification</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Classification algorithms.</p><div class="fullcomment"><div class="comment cmt"><p>Classification algorithms. In machine learning and pattern recognition,
classification refers to an algorithmic procedure for assigning a given
input object into one of a given number of categories. The input
object is formally termed an instance, and the categories are termed classes.</p><p>The instance is usually described by a vector of features, which together
constitute a description of all known characteristics of the instance.
Typically, features are either categorical (also known as nominal, i.e.
consisting of one of a set of unordered items, such as a gender of &quot;male&quot;
or &quot;female&quot;, or a blood type of &quot;A&quot;, &quot;B&quot;, &quot;AB&quot; or &quot;O&quot;), ordinal (consisting
of one of a set of ordered items, e.g. &quot;large&quot;, &quot;medium&quot; or &quot;small&quot;),
integer-valued (e.g. a count of the number of occurrences of a particular
word in an email) or real-valued (e.g. a measurement of blood pressure).</p><p>Classification normally refers to a supervised procedure, i.e. a procedure
that produces an inferred function to predict the output value of new
instances based on a training set of pairs consisting of an input object
and a desired output value. The inferred function is called a classifier
if the output is discrete or a regression function if the output is
continuous.</p><p>The inferred function should predict the correct output value for any valid
input object. This requires the learning algorithm to generalize from the
training data to unseen situations in a &quot;reasonable&quot; way.</p><p>A wide range of supervised learning algorithms is available, each with
its strengths and weaknesses. There is no single learning algorithm that
works best on all supervised learning problems. The most widely used
learning algorithms are AdaBoost and gradient boosting, support vector
machines, linear regression, linear discriminant analysis, logistic
regression, naive Bayes, decision trees, k-nearest neighbor algorithm,
and neural networks (multilayer perceptron).</p><p>If the feature vectors include features of many different kinds (discrete,
discrete ordered, counts, continuous values), some algorithms cannot be
easily applied. Many algorithms, including linear regression, logistic
regression, neural networks, and nearest neighbor methods, require that
the input features be numerical and scaled to similar ranges (e.g., to
the [-1,1] interval). Methods that employ a distance function, such as
nearest neighbor methods and support vector machines with Gaussian kernels,
are particularly sensitive to this. An advantage of decision trees (and
boosting algorithms based on decision trees) is that they easily handle
heterogeneous data.</p><p>If the input features contain redundant information (e.g., highly correlated
features), some learning algorithms (e.g., linear regression, logistic
regression, and distance based methods) will perform poorly because of
numerical instabilities. These problems can often be solved by imposing
some form of regularization.</p><p>If each of the features makes an independent contribution to the output,
then algorithms based on linear functions (e.g., linear regression,
logistic regression, linear support vector machines, naive Bayes) generally
perform well. However, if there are complex interactions among features,
then algorithms such as nonlinear support vector machines, decision trees
and neural networks work better. Linear methods can also be applied, but
the engineer must manually specify the interactions when using them.</p><p>There are several major issues to consider in supervised learning:</p><ul><li><b>Features:</b>
The accuracy of the inferred function depends strongly on how the input
object is represented. Typically, the input object is transformed into
a feature vector, which contains a number of features that are descriptive
of the object. The number of features should not be too large, because of
the curse of dimensionality; but should contain enough information to
accurately predict the output.
There are many algorithms for feature selection that seek to identify
the relevant features and discard the irrelevant ones. More generally,
dimensionality reduction may seek to map the input data into a lower
dimensional space prior to running the supervised learning algorithm.</li><li><b>Overfitting:</b>
Overfitting occurs when a statistical model describes random error
or noise instead of the underlying relationship. Overfitting generally
occurs when a model is excessively complex, such as having too many
parameters relative to the number of observations. A model which has
been overfit will generally have poor predictive performance, as it can
exaggerate minor fluctuations in the data.
The potential for overfitting depends not only on the number of parameters
and data but also the conformability of the model structure with the data
shape, and the magnitude of model error compared to the expected level
of noise or error in the data.
In order to avoid overfitting, it is necessary to use additional techniques
(e.g. cross-validation, regularization, early stopping, pruning, Bayesian
priors on parameters or model comparison), that can indicate when further
training is not resulting in better generalization. The basis of some
techniques is either (1) to explicitly penalize overly complex models,
or (2) to test the model's ability to generalize by evaluating its
performance on a set of data not used for training, which is assumed to
approximate the typical unseen data that a model will encounter.</li><li><b>Regularization:</b>
Regularization involves introducing additional information in order
to solve an ill-posed problem or to prevent over-fitting. This information
is usually of the form of a penalty for complexity, such as restrictions
for smoothness or bounds on the vector space norm.
A theoretical justification for regularization is that it attempts to impose
Occam's razor on the solution. From a Bayesian point of view, many
regularization techniques correspond to imposing certain prior distributions
on model parameters.</li><li><b>Bias-variance tradeoff:</b>
Mean squared error (MSE) can be broken down into two components:
variance and squared bias, known as the bias-variance decomposition.
Thus in order to minimize the MSE, we need to minimize both the bias and
the variance. However, this is not trivial. Therefore, there is a tradeoff
between bias and variance.
</li></ul></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.clustering" visbl="pub" class="indented2 current" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clustering"></a><a id="clustering:clustering"></a>
      <span class="permalink">
      <a href="../smile/index.html#clustering" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">clustering</span>
      </span>
      
      <p class="shortcomment cmt">Clustering analysis.</p><div class="fullcomment"><div class="comment cmt"><p>Clustering analysis. Clustering is the assignment of a set of observations
into subsets (called clusters) so that observations in the same cluster are
similar in some sense. Clustering is a method of unsupervised learning,
and a common technique for statistical data analysis used in many fields.</p><p>Hierarchical algorithms find successive clusters using previously
established clusters. These algorithms usually are either agglomerative
(&quot;bottom-up&quot;) or divisive (&quot;top-down&quot;). Agglomerative algorithms begin
with each element as a separate cluster and merge them into successively
larger clusters. Divisive algorithms begin with the whole set and proceed
to divide it into successively smaller clusters.</p><p>Partitional algorithms typically determine all clusters at once, but can
also be used as divisive algorithms in the hierarchical clustering.
Many partitional clustering algorithms require the specification of
the number of clusters to produce in the input data set, prior to
execution of the algorithm. Barring knowledge of the proper value
beforehand, the appropriate value must be determined, a problem on
its own for which a number of techniques have been developed.</p><p>Density-based clustering algorithms are devised to discover
arbitrary-shaped clusters. In this approach, a cluster is regarded as
a region in which the density of data objects exceeds a threshold.</p><p>Subspace clustering methods look for clusters that can only be seen in
a particular projection (subspace, manifold) of the data. These methods
thus can ignore irrelevant attributes. The general problem is also known
as Correlation clustering while the special case of axis-parallel subspaces
is also known as two-way clustering, co-clustering or biclustering in
bioinformatics: in these methods not only the objects are clustered but
also the features of the objects, i.e., if the data is represented in
a data matrix, the rows and columns are clustered simultaneously. They
usually do not however work with arbitrary feature combinations as in general
subspace methods.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="Operators.html" title="High level cluster analysis operators."></a>
                        <a href="Operators.html" title="High level cluster analysis operators.">
                          Operators
                        </a>
                      </li><li name="smile.feature" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="feature"></a><a id="feature:feature"></a>
      <span class="permalink">
      <a href="../smile/index.html#feature" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Feature generation, normalization and selection." href="../feature/index.html">
              <span class="name">feature</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Feature generation, normalization and selection.</p><div class="fullcomment"><div class="comment cmt"><p>Feature generation, normalization and selection.</p><p>Feature generation (or constructive induction) studies methods that modify
or enhance the representation of data objects. Feature generation techniques
search for new features that describe the objects better than the attributes
supplied with the training instances.</p><p>Many machine learning methods such as Neural Networks and SVM with Gaussian
kernel also require the features properly scaled/standardized. For example,
each variable is scaled into interval [0, 1] or to have mean 0 and standard
deviation 1. Although some method such as decision trees can handle nominal
variable directly, other methods generally require nominal variables converted
to multiple binary dummy variables to indicate the presence or absence of a
characteristic.</p><p>Feature selection is the technique of selecting a subset of relevant
features for building robust learning models. By removing most irrelevant
and redundant features from the data, feature selection helps improve the
performance of learning models by alleviating the effect of the curse of
dimensionality, enhancing generalization capability, speeding up learning
process, etc. More importantly, feature selection also helps researchers
to acquire better understanding about the data.</p><p>Feature selection algorithms typically fall into two categories: feature
ranking and subset selection. Feature ranking ranks the features by a
metric and eliminates all features that do not achieve an adequate score.
Subset selection searches the set of possible features for the optimal subset.
Clearly, an exhaustive search of optimal subset is impractical if large
numbers of features are available. Commonly, heuristic methods such as
genetic algorithms are employed for subset selection.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.imputation" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="imputation"></a><a id="imputation:imputation"></a>
      <span class="permalink">
      <a href="../smile/index.html#imputation" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Missing value imputation." href="../imputation/index.html">
              <span class="name">imputation</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Missing value imputation.</p><div class="fullcomment"><div class="comment cmt"><p>Missing value imputation. In statistics, missing data, or missing values,
occur when no data value is stored for the variable in the current
observation. Missing data are a common occurrence and can have a
significant effect on the conclusions that can be drawn from the data.</p><p>Data are missing for many reasons. Missing data can occur because of
nonresponse: no information is provided for several items or no information
is provided for a whole unit. Some items are more sensitive for nonresponse
than others, for example items about private subjects such as income.</p><p>Dropout is a type of missingness that occurs mostly when studying
development over time. In this type of study the measurement is repeated
after a certain period of time. Missingness occurs when participants drop
out before the test ends and one or more measurements are missing.</p><p>Sometimes missing values are caused by the device failure or even by
researchers themselves. It is important to question why the data is missing,
this can help with finding a solution to the problem. If the values are
missing at random there is still information about each variable in each
unit but if the values are missing systematically the problem is more severe
because the sample cannot be representative of the population.</p><p>All of the causes for missing data fit into four classes, which are based
on the relationship between the missing data mechanism and the missing and
observed values. These classes are important to understand because the
problems caused by missing data and the solutions to these problems are
different for the four classes.</p><p>The first is Missing Completely at Random (MCAR). MCAR means that the
missing data mechanism is unrelated to the values of any variables, whether
missing or observed. Data that are missing because a researcher dropped the
test tubes or survey participants accidentally skipped questions are
likely to be MCAR. If the observed values are essentially a random sample
of the full data set, complete case analysis gives the same results as
the full data set would have. Unfortunately, most missing data are not MCAR.</p><p>At the opposite end of the spectrum is Non-Ignorable (NI). NI means that
the missing data mechanism is related to the missing values. It commonly
occurs when people do not want to reveal something very personal or
unpopular about themselves. For example, if individuals with higher incomes
are less likely to reveal them on a survey than are individuals with lower
incomes, the missing data mechanism for income is non-ignorable. Whether
income is missing or observed is related to its value. Complete case
analysis can give highly biased results for NI missing data. If
proportionally more low and moderate income individuals are left in
the sample because high income people are missing, an estimate of the
mean income will be lower than the actual population mean.</p><p>In between these two extremes are Missing at Random (MAR) and Covariate
Dependent (CD). Both of these classes require that the cause of the missing
data is unrelated to the missing values, but may be related to the observed
values of other variables. MAR means that the missing values are related to
either observed covariates or response variables, whereas CD means that the
missing values are related only to covariates. As an example of CD missing
data, missing income data may be unrelated to the actual income values, but
are related to education. Perhaps people with more education are less likely
to reveal their income than those with less education.</p><p>A key distinction is whether the mechanism is ignorable (i.e., MCAR, CD, or
MAR) or non-ignorable. There are excellent techniques for handling ignorable
missing data. Non-ignorable missing data are more challenging and require a
different approach.</p><p>If it is known that the data analysis technique which is to be used isn't
content robust, it is good to consider imputing the missing data.
Once all missing values have been imputed, the dataset can then be analyzed
using standard techniques for complete data. The analysis should ideally
take into account that there is a greater degree of uncertainty than if
the imputed values had actually been observed, however, and this generally
requires some modification of the standard complete-data analysis methods.
Many imputation techniques are available.</p><p>Imputation is not the only method available for handling missing data.
The expectation-maximization algorithm is a method for finding maximum
likelihood estimates that has been widely applied to missing data problems.
In machine learning, it is sometimes possible to train a classifier directly
over the original data without imputing it first. That was shown to yield
better performance in cases where the missing data is structurally absent,
rather than missing due to measurement noise.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.manifold" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="manifold"></a><a id="manifold:manifold"></a>
      <span class="permalink">
      <a href="../smile/index.html#manifold" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Manifold learning finds a low-dimensional basis for describing
high-dimensional data." href="../manifold/index.html">
              <span class="name">manifold</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Manifold learning finds a low-dimensional basis for describing
high-dimensional data.</p><div class="fullcomment"><div class="comment cmt"><p>Manifold learning finds a low-dimensional basis for describing
high-dimensional data. Manifold learning is a popular approach to nonlinear
dimensionality reduction. Algorithms for this task are based on the idea
that the dimensionality of many data sets is only artificially high; though
each data point consists of perhaps thousands of features, it may be
described as a function of only a few underlying parameters. That is, the
data points are actually samples from a low-dimensional manifold that is
embedded in a high-dimensional space. Manifold learning algorithms attempt
to uncover these parameters in order to find a low-dimensional representation
of the data.</p><p>Some prominent approaches are locally linear embedding
(LLE), Hessian LLE, Laplacian eigenmaps, and LTSA. These techniques
construct a low-dimensional data representation using a cost function
that retains local properties of the data, and can be viewed as defining
a graph-based kernel for Kernel PCA. More recently, techniques have been
proposed that, instead of defining a fixed kernel, try to learn the kernel
using semidefinite programming. The most prominent example of such a
technique is maximum variance unfolding (MVU). The central idea of MVU
is to exactly preserve all pairwise distances between nearest neighbors
(in the inner product space), while maximizing the distances between points
that are not nearest neighbors.</p><p>An alternative approach to neighborhood preservation is through the
minimization of a cost function that measures differences between
distances in the input and output spaces. Important examples of such
techniques include classical multidimensional scaling (which is identical
to PCA), Isomap (which uses geodesic distances in the data space), diffusion
maps (which uses diffusion distances in the data space), t-SNE (which
minimizes the divergence between distributions over pairs of points),
and curvilinear component analysis.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.math" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="math"></a><a id="math:math"></a>
      <span class="permalink">
      <a href="../smile/index.html#math" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Mathematical and statistical functions." href="../math/index.html">
              <span class="name">math</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Mathematical and statistical functions.</p><div class="fullcomment"><div class="comment cmt"><p>Mathematical and statistical functions.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.mds" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mds"></a><a id="mds:mds"></a>
      <span class="permalink">
      <a href="../smile/index.html#mds" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Multidimensional scaling." href="../mds/index.html">
              <span class="name">mds</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Multidimensional scaling.</p><div class="fullcomment"><div class="comment cmt"><p>Multidimensional scaling. MDS is a set of related statistical techniques
often used in information visualization for exploring similarities or
dissimilarities in data. An MDS algorithm starts with a matrix of item-item
similarities, then assigns a location to each item in N-dimensional space.
For sufficiently small N, the resulting locations may be displayed in a
graph or 3D visualization.</p><p>The major types of MDS algorithms include:</p><p><b>Classical multidimensional scaling</b>
takes an input matrix giving dissimilarities between pairs of items and
outputs a coordinate matrix whose configuration minimizes a loss function
called strain.</p><p><b>Metric multidimensional scaling</b> is
a superset of classical MDS that generalizes the optimization procedure
to a variety of loss functions and input matrices of known distances with
weights and so on. A useful loss function in this context is called stress
which is often minimized using a procedure called stress majorization.</p><p><b>Non-metric multidimensional scaling</b> finds both a non-parametric
monotonic relationship between the dissimilarities in the item-item matrix
and the Euclidean distances between items, and the location of each item in
the low-dimensional space. The relationship is typically found using isotonic
regression.</p><p><b>Generalized multidimensional scaling</b> is
an extension of metric multidimensional scaling, in which the target
space is an arbitrary smooth non-Euclidean space. In case when the
dissimilarities are distances on a surface and the target space is another
surface, GMDS allows finding the minimum-distortion embedding of one surface
into another.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.nlp" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nlp"></a><a id="nlp:nlp"></a>
      <span class="permalink">
      <a href="../smile/index.html#nlp" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Natural language processing." href="../nlp/index.html">
              <span class="name">nlp</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Natural language processing.</p><div class="fullcomment"><div class="comment cmt"><p>Natural language processing.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.plot" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="plot"></a><a id="plot:plot"></a>
      <span class="permalink">
      <a href="../smile/index.html#plot" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Data visualization." href="../plot/index.html">
              <span class="name">plot</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Data visualization.</p><div class="fullcomment"><div class="comment cmt"><p>Data visualization.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.projection" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="projection"></a><a id="projection:projection"></a>
      <span class="permalink">
      <a href="../smile/index.html#projection" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Feature extraction." href="../projection/index.html">
              <span class="name">projection</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Feature extraction.</p><div class="fullcomment"><div class="comment cmt"><p>Feature extraction. Feature extraction transforms the data in the
high-dimensional space to a space of fewer dimensions. The data
transformation may be linear, as in principal component analysis (PCA),
but many nonlinear dimensionality reduction techniques also exist.</p><p>The main linear technique for dimensionality reduction, principal component
analysis, performs a linear mapping of the data to a lower dimensional
space in such a way that the variance of the data in the low-dimensional
representation is maximized. In practice, the correlation matrix of the
data is constructed and the eigenvectors on this matrix are computed.
The eigenvectors that correspond to the largest eigenvalues (the principal
components) can now be used to reconstruct a large fraction of the variance
of the original data. Moreover, the first few eigenvectors can often be
interpreted in terms of the large-scale physical behavior of the system.
The original space has been reduced (with data loss, but hopefully
retaining the most important variance) to the space spanned by a few
eigenvectors.</p><p>Compared to regular batch PCA algorithm, the generalized Hebbian algorithm
is an adaptive method to find the largest k eigenvectors of the covariance
matrix, assuming that the associated eigenvalues are distinct. GHA works
with an arbitrarily large sample size and the storage requirement is modest.
Another attractive feature is that, in a nonstationary environment, it
has an inherent ability to track gradual changes in the optimal solution
in an inexpensive way.</p><p>Random projection is a promising linear dimensionality reduction technique
for learning mixtures of Gaussians. The key idea of random projection arises
from the Johnson-Lindenstrauss lemma: if points in a vector space are
projected onto a randomly selected subspace of suitably high dimension,
then the distances between the points are approximately preserved.</p><p>Principal component analysis can be employed in a nonlinear way by means
of the kernel trick. The resulting technique is capable of constructing
nonlinear mappings that maximize the variance in the data. The resulting
technique is entitled Kernel PCA. Other prominent nonlinear techniques
include manifold learning techniques such as locally linear embedding
(LLE), Hessian LLE, Laplacian eigenmaps, and LTSA. These techniques
construct a low-dimensional data representation using a cost function
that retains local properties of the data, and can be viewed as defining
a graph-based kernel for Kernel PCA. More recently, techniques have been
proposed that, instead of defining a fixed kernel, try to learn the kernel
using semidefinite programming. The most prominent example of such a
technique is maximum variance unfolding (MVU). The central idea of MVU
is to exactly preserve all pairwise distances between nearest neighbors
(in the inner product space), while maximizing the distances between points
that are not nearest neighbors.</p><p>An alternative approach to neighborhood preservation is through the
minimization of a cost function that measures differences between
distances in the input and output spaces. Important examples of such
techniques include classical multidimensional scaling (which is identical
to PCA), Isomap (which uses geodesic distances in the data space), diffusion
maps (which uses diffusion distances in the data space), t-SNE (which
minimizes the divergence between distributions over pairs of points),
and curvilinear component analysis.</p><p>A different approach to nonlinear dimensionality reduction is through the
use of autoencoders, a special kind of feed-forward neural networks with
a bottle-neck hidden layer. The training of deep encoders is typically
performed using a greedy layer-wise pre-training (e.g., using a stack of
Restricted Boltzmann machines) that is followed by a finetuning stage based
on backpropagation.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.regression" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="regression"></a><a id="regression:regression"></a>
      <span class="permalink">
      <a href="../smile/index.html#regression" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Regression analysis." href="../regression/index.html">
              <span class="name">regression</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Regression analysis.</p><div class="fullcomment"><div class="comment cmt"><p>Regression analysis. Regression analysis includes any
techniques for modeling and analyzing several variables, when the focus
is on the relationship between a dependent variable and one or more
independent variables. Most commonly, regression analysis estimates the
conditional expectation of the dependent variable given the independent
variables. Therefore, the estimation target is a function of the independent
variables called the regression function. Regression analysis is widely
used for prediction and forecasting.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.sequence" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sequence"></a><a id="sequence:sequence"></a>
      <span class="permalink">
      <a href="../smile/index.html#sequence" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Learning algorithms for sequence data." href="../sequence/index.html">
              <span class="name">sequence</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Learning algorithms for sequence data.</p><div class="fullcomment"><div class="comment cmt"><p>Learning algorithms for sequence data.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.util" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="util"></a><a id="util:util"></a>
      <span class="permalink">
      <a href="../smile/index.html#util" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Utility functions." href="../util/index.html">
              <span class="name">util</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Utility functions.</p><div class="fullcomment"><div class="comment cmt"><p>Utility functions.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.validation" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="validation"></a><a id="validation:validation"></a>
      <span class="permalink">
      <a href="../smile/index.html#validation" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Model validation." href="../validation/index.html">
              <span class="name">validation</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Model validation.</p><div class="fullcomment"><div class="comment cmt"><p>Model validation.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.vq" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vq"></a><a id="vq:vq"></a>
      <span class="permalink">
      <a href="../smile/index.html#vq" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Originally used for data compression, Vector quantization (VQ)
allows the modeling of probability density functions by
the distribution of prototype vectors." href="../vq/index.html">
              <span class="name">vq</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Originally used for data compression, Vector quantization (VQ)
allows the modeling of probability density functions by
the distribution of prototype vectors.</p><div class="fullcomment"><div class="comment cmt"><p>Originally used for data compression, Vector quantization (VQ)
allows the modeling of probability density functions by
the distribution of prototype vectors. It works by dividing a large set of points
(vectors) into groups having approximately the same number of
points closest to them. Each group is represented by its centroid
point, as in K-Means and some other clustering algorithms.</p><p>Vector quantization is is based on the competitive learning paradigm,
and also closely related to sparse coding models
used in deep learning algorithms such as autoencoder.</p><p>Algorithms in this package also support the <code>partition</code>
method for clustering purpose.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li name="smile.wavelet" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wavelet"></a><a id="wavelet:wavelet"></a>
      <span class="permalink">
      <a href="../smile/index.html#wavelet" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="A wavelet is a wave-like oscillation with an amplitude that starts out at
zero, increases, and then decreases back to zero." href="../wavelet/index.html">
              <span class="name">wavelet</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">A wavelet is a wave-like oscillation with an amplitude that starts out at
zero, increases, and then decreases back to zero.</p><div class="fullcomment"><div class="comment cmt"><p>A wavelet is a wave-like oscillation with an amplitude that starts out at
zero, increases, and then decreases back to zero. Like the fast Fourier
transform (FFT), the discrete wavelet transform (DWT) is a fast, linear
operation that operates on a data vector whose length is an integer power
of 2, transforming it into a numerically different vector of the same length.
The wavelet transform is invertible and in fact orthogonal. Both FFT and DWT
can be viewed as a rotation in function space.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="package value">
      <div id="definition">
        <div class="big-circle package">p</div>
        <p id="owner"><a href="../index.html" class="extype" name="smile">smile</a></p>
        <h1>clustering<span class="permalink">
      <a href="../../smile/clustering/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">clustering</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Clustering analysis. Clustering is the assignment of a set of observations
into subsets (called clusters) so that observations in the same cluster are
similar in some sense. Clustering is a method of unsupervised learning,
and a common technique for statistical data analysis used in many fields.</p><p>Hierarchical algorithms find successive clusters using previously
established clusters. These algorithms usually are either agglomerative
(&quot;bottom-up&quot;) or divisive (&quot;top-down&quot;). Agglomerative algorithms begin
with each element as a separate cluster and merge them into successively
larger clusters. Divisive algorithms begin with the whole set and proceed
to divide it into successively smaller clusters.</p><p>Partitional algorithms typically determine all clusters at once, but can
also be used as divisive algorithms in the hierarchical clustering.
Many partitional clustering algorithms require the specification of
the number of clusters to produce in the input data set, prior to
execution of the algorithm. Barring knowledge of the proper value
beforehand, the appropriate value must be determined, a problem on
its own for which a number of techniques have been developed.</p><p>Density-based clustering algorithms are devised to discover
arbitrary-shaped clusters. In this approach, a cluster is regarded as
a region in which the density of data objects exceeds a threshold.</p><p>Subspace clustering methods look for clusters that can only be seen in
a particular projection (subspace, manifold) of the data. These methods
thus can ignore irrelevant attributes. The general problem is also known
as Correlation clustering while the special case of axis-parallel subspaces
is also known as two-way clustering, co-clustering or biclustering in
bioinformatics: in these methods not only the objects are clustered but
also the features of the objects, i.e., if the data is represented in
a data matrix, the rows and columns are clustered simultaneously. They
usually do not however work with arbitrary feature combinations as in general
subspace methods.
</p></div><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="smile.clustering"><span>clustering</span></li><li class="in" name="smile.clustering.Operators"><span>Operators</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="smile.clustering.Operators" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="OperatorsextendsAnyRef"></a><a id="Operators:Operators"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#OperatorsextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="High level cluster analysis operators." href="Operators.html">
              <span class="name">Operators</span>
            </a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">High level cluster analysis operators.</p>
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="smile.clustering.Operators#birch" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="birch(data:Array[Array[Double]],k:Int,minPts:Int,branch:Int,radius:Double):smile.clustering.BIRCH"></a><a id="birch(Array[Array[Double]],Int,Int,Int,Double):BIRCH"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#birch(data:Array[Array[Double]],k:Int,minPts:Int,branch:Int,radius:Double):smile.clustering.BIRCH" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">birch</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="minPts">minPts: <span class="extype" name="scala.Int">Int</span></span>, <span name="branch">branch: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.BIRCH">BIRCH</span></span>
      </span>
      
      <p class="shortcomment cmt">Balanced Iterative Reducing and Clustering using Hierarchies.</p><div class="fullcomment"><div class="comment cmt"><p>Balanced Iterative Reducing and Clustering using Hierarchies. BIRCH performs
hierarchical clustering over particularly large datasets. An advantage of
BIRCH is its ability to incrementally and dynamically cluster incoming,
multi-dimensional metric data points in an attempt to produce the high
quality clustering for a given set of resources (memory and time constraints).</p><p>BIRCH has several advantages. For example, each clustering decision is made
without scanning all data points and currently existing clusters. It
exploits the observation that data space is not usually uniformly occupied
and not every data point is equally important. It makes full use of
available memory to derive the finest possible sub-clusters while minimizing
I/O costs. It is also an incremental method that does not require the whole
data set in advance.</p><p>This implementation produces a clustering in three steps. First step
builds a CF (clustering feature) tree by a single scan of database.
The second step clusters the leaves of CF tree by hierarchical clustering.
Then the user can use the learned model to cluster input data in the final
step. In total, we scan the database twice.</p><h6>References:</h6><ul><li>Tian Zhang, Raghu Ramakrishnan, and Miron Livny. BIRCH: An Efficient Data Clustering Method for Very Large Databases. SIGMOD, 1996.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">minPts</dt><dd class="cmt"><p>a CF leaf will be treated as outlier if the number of its
              points is less than minPts.</p></dd><dt class="param">branch</dt><dd class="cmt"><p>the branching factor. Maximum number of children nodes.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the maximum radius of a sub-cluster.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#clarans" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clarans(data:Array[Array[Double]],k:Int,maxNeighbor:Int,numLocal:Int):smile.clustering.CLARANS[Array[Double]]"></a><a id="clarans(Array[Array[Double]],Int,Int,Int):CLARANS[Array[Double]]"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#clarans(data:Array[Array[Double]],k:Int,maxNeighbor:Int,numLocal:Int):smile.clustering.CLARANS[Array[Double]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clarans</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxNeighbor">maxNeighbor: <span class="extype" name="scala.Int">Int</span></span>, <span name="numLocal">numLocal: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.CLARANS">CLARANS</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Clustering Large Applications based upon RANdomized Search.</p><div class="fullcomment"><div class="comment cmt"><p>Clustering Large Applications based upon RANdomized Search. Euclidean distance is assumed.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxNeighbor</dt><dd class="cmt"><p>the maximum number of neighbors examined during a random search of local minima.</p></dd><dt class="param">numLocal</dt><dd class="cmt"><p>the number of local minima to search for.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#clarans" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clarans[T&lt;:Object](data:Array[T],distance:smile.math.distance.Distance[T],k:Int,maxNeighbor:Int,numLocal:Int):smile.clustering.CLARANS[T]"></a><a id="clarans[T&lt;:AnyRef](Array[T],Distance[T],Int,Int,Int):CLARANS[T]"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#clarans[T&lt;:Object](data:Array[T],distance:smile.math.distance.Distance[T],k:Int,maxNeighbor:Int,numLocal:Int):smile.clustering.CLARANS[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clarans</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.clarans.T">T</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Distance">Distance</span>[<span class="extype" name="smile.clustering.Operators.clarans.T">T</span>]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxNeighbor">maxNeighbor: <span class="extype" name="scala.Int">Int</span></span>, <span name="numLocal">numLocal: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.CLARANS">CLARANS</span>[<span class="extype" name="smile.clustering.Operators.clarans.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Clustering Large Applications based upon RANdomized Search.</p><div class="fullcomment"><div class="comment cmt"><p>Clustering Large Applications based upon RANdomized Search. CLARANS is an
efficient medoid-based clustering algorithm. The k-medoids algorithm is an
adaptation of the k-means algorithm. Rather than calculate the mean of the
items in each cluster, a representative item, or medoid, is chosen for each
cluster at each iteration. In CLARANS, the process of finding k medoids from
n objects is viewed abstractly as searching through a certain graph. In the
graph, a node is represented by a set of k objects as selected medoids. Two
nodes are neighbors if their sets differ by only one object. In each iteration,
CLARANS considers a set of randomly chosen neighbor nodes as candidate
of new medoids. We will move to the neighbor node if the neighbor
is a better choice for medoids. Otherwise, a local optima is discovered. The
entire process is repeated multiple time to find better.</p><p>CLARANS has two parameters: the maximum number of neighbors examined
(maxNeighbor) and the number of local minima obtained (numLocal). The
higher the value of maxNeighbor, the closer is CLARANS to PAM, and the
longer is each search of a local minima. But the quality of such a local
minima is higher and fewer local minima needs to be obtained.</p><h6>References:</h6><ul><li>R. Ng and J. Han. CLARANS: A Method for Clustering Objects for Spatial Data Mining. IEEE TRANS. KNOWLEDGE AND DATA ENGINEERING, 2002.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance/dissimilarity measure.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxNeighbor</dt><dd class="cmt"><p>the maximum number of neighbors examined during a random search of local minima.</p></dd><dt class="param">numLocal</dt><dd class="cmt"><p>the number of local minima to search for.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#dac" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dac(data:Array[Array[Double]],k:Int,alpha:Double):smile.clustering.DeterministicAnnealing"></a><a id="dac(Array[Array[Double]],Int,Double):DeterministicAnnealing"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#dac(data:Array[Array[Double]],k:Int,alpha:Double):smile.clustering.DeterministicAnnealing" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dac</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="alpha">alpha: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.9</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DeterministicAnnealing">DeterministicAnnealing</span></span>
      </span>
      
      <p class="shortcomment cmt">Deterministic annealing clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Deterministic annealing clustering. Deterministic annealing extends
soft-clustering to an annealing process.
For each temperature value, the algorithm iterates between the calculation
of all posteriori probabilities and the update of the centroids vectors,
until convergence is reached. The annealing starts with a high temperature.
Here, all centroids vectors converge to the center of the pattern
distribution (independent of their initial positions). Below a critical
temperature the vectors start to split. Further decreasing the temperature
leads to more splittings until all centroids vectors are separate. The
annealing can therefore avoid (if it is sufficiently slow) the convergence
to local minima.</p><h6>References:</h6><ul><li>Kenneth Rose. Deterministic Annealing for Clustering, Compression, Classification, Regression, and Speech Recognition.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the maximum number of clusters.</p></dd><dt class="param">alpha</dt><dd class="cmt"><p>the temperature T is decreasing as T = T * alpha. alpha has
             to be in (0, 1).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#dbscan" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dbscan(data:Array[Array[Double]],minPts:Int,radius:Double):smile.clustering.DBScan[Array[Double]]"></a><a id="dbscan(Array[Array[Double]],Int,Double):DBScan[Array[Double]]"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#dbscan(data:Array[Array[Double]],minPts:Int,radius:Double):smile.clustering.DBScan[Array[Double]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dbscan</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="minPts">minPts: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DBScan">DBScan</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">DBSCan with Euclidean distance.</p><div class="fullcomment"><div class="comment cmt"><p>DBSCan with Euclidean distance.
DBScan finds a number of clusters starting from the estimated density
distribution of corresponding nodes.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">minPts</dt><dd class="cmt"><p>the minimum number of neighbors for a core data point.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#dbscan" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dbscan[T&lt;:Object](data:Array[T],distance:smile.math.distance.Metric[T],minPts:Int,radius:Double):smile.clustering.DBScan[T]"></a><a id="dbscan[T&lt;:AnyRef](Array[T],Metric[T],Int,Double):DBScan[T]"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#dbscan[T&lt;:Object](data:Array[T],distance:smile.math.distance.Metric[T],minPts:Int,radius:Double):smile.clustering.DBScan[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dbscan</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Metric">Metric</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>, <span name="minPts">minPts: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DBScan">DBScan</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Density-Based Spatial Clustering of Applications with Noise.</p><div class="fullcomment"><div class="comment cmt"><p>Density-Based Spatial Clustering of Applications with Noise.
DBScan finds a number of clusters starting from the estimated density
distribution of corresponding nodes.
Cover Tree is used for nearest neighbor search.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance metric.</p></dd><dt class="param">minPts</dt><dd class="cmt"><p>the minimum number of neighbors for a core data point.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#dbscan" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dbscan[T&lt;:Object](data:Array[T],nns:smile.neighbor.RNNSearch[T,T],minPts:Int,radius:Double):smile.clustering.DBScan[T]"></a><a id="dbscan[T&lt;:AnyRef](Array[T],RNNSearch[T,T],Int,Double):DBScan[T]"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#dbscan[T&lt;:Object](data:Array[T],nns:smile.neighbor.RNNSearch[T,T],minPts:Int,radius:Double):smile.clustering.DBScan[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dbscan</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>, <span name="nns">nns: <span class="extype" name="smile.neighbor.RNNSearch">RNNSearch</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>, <span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>, <span name="minPts">minPts: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DBScan">DBScan</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Density-Based Spatial Clustering of Applications with Noise.</p><div class="fullcomment"><div class="comment cmt"><p>Density-Based Spatial Clustering of Applications with Noise.
DBScan finds a number of clusters starting from the estimated density
distribution of corresponding nodes.</p><p>DBScan requires two parameters: radius (i.e. neighborhood radius) and the
number of minimum points required to form a cluster (minPts). It starts
with an arbitrary starting point that has not been visited. This point's
neighborhood is retrieved, and if it contains sufficient number of points,
a cluster is started. Otherwise, the point is labeled as noise. Note that
this point might later be found in a sufficiently sized radius-environment
of a different point and hence be made part of a cluster.</p><p>If a point is found to be part of a cluster, its neighborhood is also
part of that cluster. Hence, all points that are found within the
neighborhood are added, as is their own neighborhood. This process
continues until the cluster is completely found. Then, a new unvisited point
is retrieved and processed, leading to the discovery of a further cluster
of noise.</p><p>DBScan visits each point of the database, possibly multiple times (e.g.,
as candidates to different clusters). For practical considerations, however,
the time complexity is mostly governed by the number of nearest neighbor
queries. DBScan executes exactly one such query for each point, and if
an indexing structure is used that executes such a neighborhood query
in O(log n), an overall runtime complexity of O(n log n) is obtained.</p><p>DBScan has many advantages such as</p><ul><li>DBScan does not need to know the number of clusters in the data
   a priori, as opposed to k-means.</li><li>DBScan can find arbitrarily shaped clusters. It can even find clusters
   completely surrounded by (but not connected to) a different cluster.
   Due to the MinPts parameter, the so-called single-link effect
   (different clusters being connected by a thin line of points) is reduced.</li><li>DBScan has a notion of noise.</li><li>DBScan requires just two parameters and is mostly insensitive to the
   ordering of the points in the database. (Only points sitting on the
   edge of two different clusters might swap cluster membership if the
   ordering of the points is changed, and the cluster assignment is unique
   only up to isomorphism.)</li></ul><p>On the other hand, DBScan has the disadvantages of</p><ul><li>In high dimensional space, the data are sparse everywhere
   because of the curse of dimensionality. Therefore, DBScan doesn't
   work well on high-dimensional data in general.</li><li>DBScan does not respond well to data sets with varying densities.</li></ul><h6>References:</h6><ul><li>Martin Ester, Hans-Peter Kriegel, Jorg Sander, Xiaowei Xu (1996-). A density-based algorithm for discovering clusters in large spatial databases with noise&quot;. KDD, 1996.</li><li>Jorg Sander, Martin Ester, Hans-Peter  Kriegel, Xiaowei Xu. (1998). Density-Based Clustering in Spatial Databases: The Algorithm GDBSCAN and Its Applications. 1998.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">nns</dt><dd class="cmt"><p>the data structure for neighborhood search.</p></dd><dt class="param">minPts</dt><dd class="cmt"><p>the minimum number of neighbors for a core data point.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#denclue" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="denclue(data:Array[Array[Double]],sigma:Double,m:Int):smile.clustering.DENCLUE"></a><a id="denclue(Array[Array[Double]],Double,Int):DENCLUE"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#denclue(data:Array[Array[Double]],sigma:Double,m:Int):smile.clustering.DENCLUE" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">denclue</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="sigma">sigma: <span class="extype" name="scala.Double">Double</span></span>, <span name="m">m: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DENCLUE">DENCLUE</span></span>
      </span>
      
      <p class="shortcomment cmt">DENsity CLUstering.</p><div class="fullcomment"><div class="comment cmt"><p>DENsity CLUstering. The DENCLUE algorithm employs a cluster model based on
kernel density estimation. A cluster is defined by a local maximum of the
estimated density function. Data points going to the same local maximum
are put into the same cluster.</p><p>Clearly, DENCLUE doesn't work on data with uniform distribution. In high
dimensional space, the data always look like uniformly distributed because
of the curse of dimensionality. Therefore, DENCLUDE doesn't work well on
high-dimensional data in general.</p><h6>References:</h6><ul><li>A. Hinneburg and D. A. Keim. A general approach to clustering in large databases with noise. Knowledge and Information Systems, 5(4):387-415, 2003.</li><li>Alexander Hinneburg and Hans-Henning Gabriel. DENCLUE 2.0: Fast Clustering based on Kernel Density Estimation. IDA, 2007.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">sigma</dt><dd class="cmt"><p>the smooth parameter in the Gaussian kernel. The user can
             choose sigma such that number of density attractors is constant for a
             long interval of sigma.</p></dd><dt class="param">m</dt><dd class="cmt"><p>the number of selected samples used in the iteration.
         This number should be much smaller than the number of data points
         to speed up the algorithm. It should also be large enough to capture
         the sufficient information of underlying distribution.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#gmeans" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="gmeans(data:Array[Array[Double]],k:Int):smile.clustering.GMeans"></a><a id="gmeans(Array[Array[Double]],Int):GMeans"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#gmeans(data:Array[Array[Double]],k:Int):smile.clustering.GMeans" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gmeans</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">100</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.GMeans">GMeans</span></span>
      </span>
      
      <p class="shortcomment cmt">G-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters by normality test.</p><div class="fullcomment"><div class="comment cmt"><p>G-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters by normality test.
The G-means algorithm is based on a statistical test for the hypothesis
that a subset of data follows a Gaussian distribution. G-means runs
k-means with increasing k in a hierarchical fashion until the test accepts
the hypothesis that the data assigned to each k-means center are Gaussian.</p><h6>References:</h6><ul><li>G. Hamerly and C. Elkan. Learning the k in k-means. NIPS, 2003.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the maximum number of clusters.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#hclust" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hclust(proximity:Array[Array[Double]],method:String):smile.clustering.HierarchicalClustering"></a><a id="hclust(Array[Array[Double]],String):HierarchicalClustering"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#hclust(proximity:Array[Array[Double]],method:String):smile.clustering.HierarchicalClustering" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hclust</span><span class="params">(<span name="proximity">proximity: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="method">method: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.HierarchicalClustering">HierarchicalClustering</span></span>
      </span>
      
      <p class="shortcomment cmt">Agglomerative Hierarchical Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Agglomerative Hierarchical Clustering. This method
seeks to build a hierarchy of clusters in a bottom up approach: each
observation starts in its own cluster, and pairs of clusters are merged as
one moves up the hierarchy. The results of hierarchical clustering are
usually presented in a dendrogram.</p><p>In general, the merges are determined in a greedy manner. In order to decide
which clusters should be combined, a measure of dissimilarity between sets
of observations is required. In most methods of hierarchical clustering,
this is achieved by use of an appropriate metric, and a linkage criteria
which specifies the dissimilarity of sets as a function of the pairwise
distances of observations in the sets.</p><p>Hierarchical clustering has the distinct advantage that any valid measure
of distance can be used. In fact, the observations themselves are not
required: all that is used is a matrix of distances.</p><h4> References </h4><ul><li>David Eppstein. Fast hierarchical clustering and other applications of dynamic closest pairs. SODA 1998.
</li></ul></div><dl class="paramcmts block"><dt class="param">proximity</dt><dd class="cmt"><p>The proximity matrix to store the distance measure of
                 dissimilarity. To save space, we only need the lower half of matrix.</p></dd><dt class="param">method</dt><dd class="cmt"><p>the agglomeration method to merge clusters. This should be one of
               &quot;single&quot;, &quot;complete&quot;, &quot;upgma&quot;, &quot;upgmc&quot;, &quot;wpgma&quot;, &quot;wpgmc&quot;, and &quot;ward&quot;.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#kmeans" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="kmeans(data:Array[Array[Double]],k:Int,maxIter:Int,runs:Int):smile.clustering.KMeans"></a><a id="kmeans(Array[Array[Double]],Int,Int,Int):KMeans"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#kmeans(data:Array[Array[Double]],k:Int,maxIter:Int,runs:Int):smile.clustering.KMeans" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">kmeans</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxIter">maxIter: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">100</span></span>, <span name="runs">runs: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.KMeans">KMeans</span></span>
      </span>
      
      <p class="shortcomment cmt">K-Means clustering.</p><div class="fullcomment"><div class="comment cmt"><p>K-Means clustering. The algorithm partitions n observations into k clusters in which
each observation belongs to the cluster with the nearest mean.
Although finding an exact solution to the k-means problem for arbitrary
input is NP-hard, the standard approach to finding an approximate solution
(often called Lloyd's algorithm or the k-means algorithm) is used widely
and frequently finds reasonable solutions quickly.</p><p>However, the k-means algorithm has at least two major theoretic shortcomings:</p><ul><li>First, it has been shown that the worst case running time of the
algorithm is super-polynomial in the input size.</li><li>Second, the approximation found can be arbitrarily bad with respect
to the objective function compared to the optimal learn.</li></ul><p>In this implementation, we use k-means++ which addresses the second of these
obstacles by specifying a procedure to initialize the cluster centers before
proceeding with the standard k-means optimization iterations. With the
k-means++ initialization, the algorithm is guaranteed to find a solution
that is O(log k) competitive to the optimal k-means solution.</p><p>We also use k-d trees to speed up each k-means step as described in the filter
algorithm by Kanungo, et al.</p><p>K-means is a hard clustering method, i.e. each sample is assigned to
a specific cluster. In contrast, soft clustering, e.g. the
Expectation-Maximization algorithm for Gaussian mixtures, assign samples
to different clusters with different probabilities.</p><h6>References:</h6><ul><li>Tapas Kanungo, David M. Mount, Nathan S. Netanyahu, Christine D. Piatko, Ruth Silverman, and Angela Y. Wu. An Efficient k-Means Clustering Algorithm: Analysis and Implementation. IEEE TRANS. PAMI, 2002.</li><li>D. Arthur and S. Vassilvitskii. &quot;K-means++: the advantages of careful seeding&quot;. ACM-SIAM symposium on Discrete algorithms, 1027-1035, 2007.</li><li>Anna D. Peterson, Arka P. Ghosh and Ranjan Maitra. A systematic evaluation of different methods for initializing the K-means clustering algorithm. 2010.</li></ul><p>This method runs the algorithm for given times and return the best one with smallest distortion.</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>the maximum number of iterations for each running.</p></dd><dt class="param">runs</dt><dd class="cmt"><p>the number of runs of K-Means algorithm.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#mec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mec[T&lt;:Object](data:Array[T],nns:smile.neighbor.RNNSearch[T,T],k:Int,radius:Double,y:Array[Int]):smile.clustering.MEC[T]"></a><a id="mec[T&lt;:AnyRef](Array[T],RNNSearch[T,T],Int,Double,Array[Int]):MEC[T]"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#mec[T&lt;:Object](data:Array[T],nns:smile.neighbor.RNNSearch[T,T],k:Int,radius:Double,y:Array[Int]):smile.clustering.MEC[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mec</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="nns">nns: <span class="extype" name="smile.neighbor.RNNSearch">RNNSearch</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>, <span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Int">Int</span>]</span>)</span><span class="result">: <span class="extype" name="smile.clustering.MEC">MEC</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Nonparametric Minimum Conditional Entropy Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Nonparametric Minimum Conditional Entropy Clustering.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">nns</dt><dd class="cmt"><p>the data structure for neighborhood search.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters. Note that this is just a hint. The final
         number of clusters may be less.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#mec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mec(data:Array[Array[Double]],k:Int,radius:Double):smile.clustering.MEC[Array[Double]]"></a><a id="mec(Array[Array[Double]],Int,Double):MEC[Array[Double]]"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#mec(data:Array[Array[Double]],k:Int,radius:Double):smile.clustering.MEC[Array[Double]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mec</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.MEC">MEC</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Nonparametric Minimum Conditional Entropy Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Nonparametric Minimum Conditional Entropy Clustering. Assume Euclidean distance.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters. Note that this is just a hint. The final
         number of clusters may be less.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#mec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mec[T&lt;:Object](data:Array[T],distance:smile.math.distance.Metric[T],k:Int,radius:Double):smile.clustering.MEC[T]"></a><a id="mec[T&lt;:AnyRef](Array[T],Metric[T],Int,Double):MEC[T]"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#mec[T&lt;:Object](data:Array[T],distance:smile.math.distance.Metric[T],k:Int,radius:Double):smile.clustering.MEC[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mec</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Metric">Metric</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.MEC">MEC</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Nonparametric Minimum Conditional Entropy Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Nonparametric Minimum Conditional Entropy Clustering.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance measure for neighborhood search.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters. Note that this is just a hint. The final
         number of clusters may be less.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#mec" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mec[T&lt;:Object](data:Array[T],distance:smile.math.distance.Distance[T],k:Int,radius:Double):smile.clustering.MEC[T]"></a><a id="mec[T&lt;:AnyRef](Array[T],Distance[T],Int,Double):MEC[T]"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#mec[T&lt;:Object](data:Array[T],distance:smile.math.distance.Distance[T],k:Int,radius:Double):smile.clustering.MEC[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mec</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Distance">Distance</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.MEC">MEC</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Nonparametric Minimum Conditional Entropy Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Nonparametric Minimum Conditional Entropy Clustering. This method performs
very well especially when the exact number of clusters is unknown.
The method can also correctly reveal the structure of data and effectively
identify outliers simultaneously.</p><p>The clustering criterion is based on the conditional entropy H(C | x), where
C is the cluster label and x is an observation. According to Fano's
inequality, we can estimate C with a low probability of error only if the
conditional entropy H(C | X) is small. MEC also generalizes the criterion
by replacing Shannon's entropy with Havrda-Charvat's structural
&alpha;-entropy. Interestingly, the minimum entropy criterion based
on structural &alpha;-entropy is equal to the probability error of the
nearest neighbor method when &alpha;= 2. To estimate p(C | x), MEC employs
Parzen density estimation, a nonparametric approach.</p><p>MEC is an iterative algorithm starting with an initial partition given by
any other clustering methods, e.g. k-means, CLARNAS, hierarchical clustering,
etc. Note that a random initialization is NOT appropriate.</p><h6>References:</h6><ul><li>Haifeng Li, Keshu Zhang, and Tao Jiang. Minimum Entropy Clustering and Applications to Gene Expression Analysis. CSB, 2004.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance measure for neighborhood search.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters. Note that this is just a hint. The final
         number of clusters may be less.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#sib" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sib(data:smile.data.SparseDataset,k:Int,maxIter:Int,runs:Int):smile.clustering.SIB"></a><a id="sib(SparseDataset,Int,Int,Int):SIB"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#sib(data:smile.data.SparseDataset,k:Int,maxIter:Int,runs:Int):smile.clustering.SIB" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sib</span><span class="params">(<span name="data">data: <span class="extype" name="smile.data.SparseDataset">SparseDataset</span></span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxIter">maxIter: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">100</span></span>, <span name="runs">runs: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">8</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SIB">SIB</span></span>
      </span>
      
      <p class="shortcomment cmt">The Sequential Information Bottleneck algorithm on sparse dataset.</p><div class="fullcomment"><div class="comment cmt"><p>The Sequential Information Bottleneck algorithm on sparse dataset.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>the maximum number of iterations.</p></dd><dt class="param">runs</dt><dd class="cmt"><p>the number of runs of SIB algorithm.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#sib" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sib(data:Array[Array[Double]],k:Int,maxIter:Int,runs:Int):smile.clustering.SIB"></a><a id="sib(Array[Array[Double]],Int,Int,Int):SIB"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#sib(data:Array[Array[Double]],k:Int,maxIter:Int,runs:Int):smile.clustering.SIB" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sib</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxIter">maxIter: <span class="extype" name="scala.Int">Int</span></span>, <span name="runs">runs: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SIB">SIB</span></span>
      </span>
      
      <p class="shortcomment cmt">The Sequential Information Bottleneck algorithm.</p><div class="fullcomment"><div class="comment cmt"><p>The Sequential Information Bottleneck algorithm. SIB clusters co-occurrence
data such as text documents vs words. SIB is guaranteed to converge to a local
maximum of the information. Moreover, the time and space complexity are
significantly improved in contrast to the agglomerative IB algorithm.</p><p>In analogy to K-Means, SIB's update formulas are essentially same as the
EM algorithm for estimating finite Gaussian mixture model by replacing
regular Euclidean distance with Kullback-Leibler divergence, which is
clearly a better dissimilarity measure for co-occurrence data. However,
the common batch updating rule (assigning all instances to nearest centroids
and then updating centroids) of K-Means won't work in SIB, which has
to work in a sequential way (reassigning (if better) each instance then
immediately update related centroids). It might be because K-L divergence
is very sensitive and the centroids may be significantly changed in each
iteration in batch updating rule.</p><p>Note that this implementation has a little difference from the original
paper, in which a weighted Jensen-Shannon divergence is employed as a
criterion to assign a randomly-picked sample to a different cluster.
However, this doesn't work well in some cases as we experienced probably
because the weighted JS divergence gives too much weight to clusters which
is much larger than a single sample. In this implementation, we instead
use the regular/unweighted Jensen-Shannon divergence.</p><h6>References:</h6><ul><li>N. Tishby, F.C. Pereira, and W. Bialek. The information bottleneck method. 1999.</li><li>N. Slonim, N. Friedman, and N. Tishby. Unsupervised document classification using sequential information maximization. ACM SIGIR, 2002.</li><li>Jaakko Peltonen, Janne Sinkkonen, and Samuel Kaski. Sequential information bottleneck for finite data. ICML, 2004.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>the maximum number of iterations.</p></dd><dt class="param">runs</dt><dd class="cmt"><p>the number of runs of SIB algorithm.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#specc" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="specc(data:Array[Array[Double]],k:Int,l:Int,sigma:Double):smile.clustering.SpectralClustering"></a><a id="specc(Array[Array[Double]],Int,Int,Double):SpectralClustering"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#specc(data:Array[Array[Double]],k:Int,l:Int,sigma:Double):smile.clustering.SpectralClustering" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">specc</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="l">l: <span class="extype" name="scala.Int">Int</span></span>, <span name="sigma">sigma: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SpectralClustering">SpectralClustering</span></span>
      </span>
      
      <p class="shortcomment cmt">Spectral clustering with Nystrom approximation.</p><div class="fullcomment"><div class="comment cmt"><p>Spectral clustering with Nystrom approximation.</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the dataset for clustering.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">l</dt><dd class="cmt"><p>the number of random samples for Nystrom approximation.</p></dd><dt class="param">sigma</dt><dd class="cmt"><p>the smooth/width parameter of Gaussian kernel, which
             is a somewhat sensitive parameter. To search for the best setting,
             one may pick the value that gives the tightest clusters (smallest
             distortion, see { @link #distortion()}) in feature space.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#specc" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="specc(data:Array[Array[Double]],k:Int,sigma:Double):smile.clustering.SpectralClustering"></a><a id="specc(Array[Array[Double]],Int,Double):SpectralClustering"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#specc(data:Array[Array[Double]],k:Int,sigma:Double):smile.clustering.SpectralClustering" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">specc</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="sigma">sigma: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SpectralClustering">SpectralClustering</span></span>
      </span>
      
      <p class="shortcomment cmt">Spectral clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Spectral clustering.</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the dataset for clustering.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">sigma</dt><dd class="cmt"><p>the smooth/width parameter of Gaussian kernel, which
             is a somewhat sensitive parameter. To search for the best setting,
             one may pick the value that gives the tightest clusters (smallest
             distortion, see { @link #distortion()}) in feature space.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#specc" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="specc(W:Array[Array[Double]],k:Int):smile.clustering.SpectralClustering"></a><a id="specc(Array[Array[Double]],Int):SpectralClustering"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#specc(W:Array[Array[Double]],k:Int):smile.clustering.SpectralClustering" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">specc</span><span class="params">(<span name="W">W: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SpectralClustering">SpectralClustering</span></span>
      </span>
      
      <p class="shortcomment cmt">Spectral Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Spectral Clustering. Given a set of data points, the similarity matrix may
be defined as a matrix S where S<sub>ij</sub> represents a measure of the
similarity between points. Spectral clustering techniques make use of the
spectrum of the similarity matrix of the data to perform dimensionality
reduction for clustering in fewer dimensions. Then the clustering will
be performed in the dimension-reduce space, in which clusters of non-convex
shape may become tight. There are some intriguing similarities between
spectral clustering methods and kernel PCA, which has been empirically
observed to perform clustering.</p><h6>References:</h6><ul><li>A.Y. Ng, M.I. Jordan, and Y. Weiss. On Spectral Clustering: Analysis and an algorithm. NIPS, 2001.</li><li>Marina Maila and Jianbo Shi. Learning segmentation by random walks. NIPS, 2000.</li><li>Deepak Verma and Marina Meila. A Comparison of Spectral Clustering Algorithms. 2003.
</li></ul></div><dl class="paramcmts block"><dt class="param">W</dt><dd class="cmt"><p>the adjacency matrix of graph.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#xmeans" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="xmeans(data:Array[Array[Double]],k:Int):smile.clustering.XMeans"></a><a id="xmeans(Array[Array[Double]],Int):XMeans"></a>
      <span class="permalink">
      <a href="../../smile/clustering/index.html#xmeans(data:Array[Array[Double]],k:Int):smile.clustering.XMeans" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">xmeans</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">100</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.XMeans">XMeans</span></span>
      </span>
      
      <p class="shortcomment cmt">X-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters based on BIC scores.</p><div class="fullcomment"><div class="comment cmt"><p>X-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters based on BIC scores.
Starting with only one cluster, the X-Means algorithm goes into action
after each run of K-Means, making local decisions about which subset of the
current centroids should split themselves in order to better fit the data.
The splitting decision is done by computing the Bayesian Information
Criterion (BIC).</p><h6>References:</h6><ul><li>Dan Pelleg and Andrew Moore. X-means: Extending K-means with Efficient Estimation of the Number of Clusters. ICML, 2000.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the maximum number of clusters.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="smile.clustering.Operators">
              <h3>Inherited from <a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
