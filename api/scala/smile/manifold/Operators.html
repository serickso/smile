<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>Smile - Statistical Machine Intelligence and Learning Engine  - smile.manifold.Operators</title>
          <meta name="description" content="Smile - Statistical Machine Intelligence and Learning Engine - smile.manifold.Operators" />
          <meta name="keywords" content="Smile Statistical Machine Intelligence and Learning Engine smile.manifold.Operators" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../lib/index.js"></script>
      <script type="text/javascript" src="../../index.js"></script>
      <script type="text/javascript" src="../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">Smile - Statistical Machine Intelligence and Learning Engine<span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="High level Smile operators in Scala." href="../../index.html">
              <span class="name">root</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">High level Smile operators in Scala.</p><div class="fullcomment"><div class="comment cmt"><p>High level Smile operators in Scala.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.smile" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="smile"></a><a id="smile:smile"></a>
      <span class="permalink">
      <a href="index.html#smile" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html">
              <span class="name">smile</span>
            </a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="smile.manifold" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="manifold"></a><a id="manifold:manifold"></a>
      <span class="permalink">
      <a href="../smile/index.html#manifold" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Manifold learning finds a low-dimensional basis for describing
high-dimensional data." href="index.html">
              <span class="name">manifold</span>
            </a>
      </span>
      
      <p class="shortcomment cmt">Manifold learning finds a low-dimensional basis for describing
high-dimensional data.</p><div class="fullcomment"><div class="comment cmt"><p>Manifold learning finds a low-dimensional basis for describing
high-dimensional data. Manifold learning is a popular approach to nonlinear
dimensionality reduction. Algorithms for this task are based on the idea
that the dimensionality of many data sets is only artificially high; though
each data point consists of perhaps thousands of features, it may be
described as a function of only a few underlying parameters. That is, the
data points are actually samples from a low-dimensional manifold that is
embedded in a high-dimensional space. Manifold learning algorithms attempt
to uncover these parameters in order to find a low-dimensional representation
of the data.</p><p>Some prominent approaches are locally linear embedding
(LLE), Hessian LLE, Laplacian eigenmaps, and LTSA. These techniques
construct a low-dimensional data representation using a cost function
that retains local properties of the data, and can be viewed as defining
a graph-based kernel for Kernel PCA. More recently, techniques have been
proposed that, instead of defining a fixed kernel, try to learn the kernel
using semidefinite programming. The most prominent example of such a
technique is maximum variance unfolding (MVU). The central idea of MVU
is to exactly preserve all pairwise distances between nearest neighbors
(in the inner product space), while maximizing the distances between points
that are not nearest neighbors.</p><p>An alternative approach to neighborhood preservation is through the
minimization of a cost function that measures differences between
distances in the input and output spaces. Important examples of such
techniques include classical multidimensional scaling (which is identical
to PCA), Isomap (which uses geodesic distances in the data space), diffusion
maps (which uses diffusion distances in the data space), t-SNE (which
minimizes the divergence between distributions over pairs of points),
and curvilinear component analysis.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="smile">smile</a></dd></dl></div>
    </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="" title="High level manifold learning operators."></a>
                        <a href="" title="High level manifold learning operators.">
                          Operators
                        </a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="trait type">
      <div id="definition">
        <div class="big-circle trait">t</div>
        <p id="owner"><a href="../index.html" class="extype" name="smile">smile</a>.<a href="index.html" class="extype" name="smile.manifold">manifold</a></p>
        <h1>Operators<span class="permalink">
      <a href="../../smile/manifold/Operators.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">Operators</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>High level manifold learning operators.
</p></div><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="smile.manifold.Operators"><span>Operators</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
                  <span class="filtertype">Implicitly<br />
                  </span>
                  <ol id="implicits"> <li class="in" name="scala.Predef.any2stringadd" data-hidden="true"><span>by any2stringadd</span></li><li class="in" name="scala.Predef.StringFormat" data-hidden="true"><span>by StringFormat</span></li><li class="in" name="scala.Predef.Ensuring" data-hidden="true"><span>by Ensuring</span></li><li class="in" name="scala.Predef.ArrowAssoc" data-hidden="true"><span>by ArrowAssoc</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Predef.any2stringadd#+" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="+(other:String):String"></a><a id="+(String):String"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#+(other:String):String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus" class="implicit">+</span><span class="params">(<span name="other">other: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to
            <span class="extype" name="scala.Predef.any2stringadd">any2stringadd</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>] performed by method any2stringadd in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>any2stringadd</dd></dl></div>
    </li><li name="scala.Predef.ArrowAssoc#-&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="-&gt;[B](y:B):(A,B)"></a><a id="-&gt;[B](B):(Operators,B)"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#-&gt;[B](y:B):(A,B)" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $minus$greater" class="implicit">-&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span class="extype" name="scala.Predef.ArrowAssoc.-&gt;.B">B</span></span>)</span><span class="result">: (<a href="" class="extype" name="smile.manifold.Operators">Operators</a>, <span class="extype" name="scala.Predef.ArrowAssoc.-&gt;.B">B</span>)</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to
            <span class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>] performed by method ArrowAssoc in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd>
                <span class="name">@inline</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.Predef.Ensuring#ensuring" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A"></a><a id="ensuring((Operators)⇒Boolean,⇒Any):Operators"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" class="extype" name="smile.manifold.Operators">Operators</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="msg">msg: ⇒ <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <a href="" class="extype" name="smile.manifold.Operators">Operators</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to
            <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>] performed by method Ensuring in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div>
    </li><li name="scala.Predef.Ensuring#ensuring" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ensuring(cond:A=&gt;Boolean):A"></a><a id="ensuring((Operators)⇒Boolean):Operators"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#ensuring(cond:A=&gt;Boolean):A" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" class="extype" name="smile.manifold.Operators">Operators</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="" class="extype" name="smile.manifold.Operators">Operators</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to
            <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>] performed by method Ensuring in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div>
    </li><li name="scala.Predef.Ensuring#ensuring" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ensuring(cond:Boolean,msg:=&gt;Any):A"></a><a id="ensuring(Boolean,⇒Any):Operators"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#ensuring(cond:Boolean,msg:=&gt;Any):A" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="msg">msg: ⇒ <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <a href="" class="extype" name="smile.manifold.Operators">Operators</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to
            <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>] performed by method Ensuring in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div>
    </li><li name="scala.Predef.Ensuring#ensuring" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ensuring(cond:Boolean):A"></a><a id="ensuring(Boolean):Operators"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#ensuring(cond:Boolean):A" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="" class="extype" name="smile.manifold.Operators">Operators</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to
            <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>] performed by method Ensuring in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.Predef.StringFormat#formatted" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="formatted(fmtstr:String):String"></a><a id="formatted(String):String"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#formatted(fmtstr:String):String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">formatted</span><span class="params">(<span name="fmtstr">fmtstr: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to
            <span class="extype" name="scala.Predef.StringFormat">StringFormat</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>] performed by method StringFormat in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>StringFormat</dd><dt>Annotations</dt><dd>
                <span class="name">@inline</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="smile.manifold.Operators#isomap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isomap(data:Array[Array[Double]],d:Int,k:Int,CIsomap:Boolean):smile.manifold.IsoMap"></a><a id="isomap(Array[Array[Double]],Int,Int,Boolean):IsoMap"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#isomap(data:Array[Array[Double]],d:Int,k:Int,CIsomap:Boolean):smile.manifold.IsoMap" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isomap</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="d">d: <span class="extype" name="scala.Int">Int</span></span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="CIsomap">CIsomap: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="result">: <span class="extype" name="smile.manifold.IsoMap">IsoMap</span></span>
      </span>
      
      <p class="shortcomment cmt">Isometric feature mapping.</p><div class="fullcomment"><div class="comment cmt"><p>Isometric feature mapping. Isomap is a widely used low-dimensional embedding methods,
where geodesic distances on a weighted graph are incorporated with the
classical multidimensional scaling. Isomap is used for computing a
quasi-isometric, low-dimensional embedding of a set of high-dimensional
data points. Isomap is highly efficient and generally applicable to a broad
range of data sources and dimensionalities.</p><p>To be specific, the classical MDS performs low-dimensional embedding based
on the pairwise distance between data points, which is generally measured
using straight-line Euclidean distance. Isomap is distinguished by
its use of the geodesic distance induced by a neighborhood graph
embedded in the classical scaling. This is done to incorporate manifold
structure in the resulting embedding. Isomap defines the geodesic distance
to be the sum of edge weights along the shortest path between two nodes.
The top n eigenvectors of the geodesic distance matrix, represent the
coordinates in the new n-dimensional Euclidean space.</p><p>The connectivity of each data point in the neighborhood graph is defined
as its nearest k Euclidean neighbors in the high-dimensional space. This
step is vulnerable to &quot;short-circuit errors&quot; if k is too large with
respect to the manifold structure or if noise in the data moves the
points slightly off the manifold. Even a single short-circuit error
can alter many entries in the geodesic distance matrix, which in turn
can lead to a drastically different (and incorrect) low-dimensional
embedding. Conversely, if k is too small, the neighborhood graph may
become too sparse to approximate geodesic paths accurately.</p><p>This class implements C-Isomap that involves magnifying the regions
of high density and shrink the regions of low density of data points
in the manifold. Edge weights that are maximized in Multi-Dimensional
Scaling(MDS) are modified, with everything else remaining unaffected.</p><h6>References:</h6><ul><li>J. B. Tenenbaum, V. de Silva and J. C. Langford  A Global Geometric Framework for Nonlinear Dimensionality Reduction. Science 290(5500):2319-2323, 2000.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">d</dt><dd class="cmt"><p>the dimension of the manifold.</p></dd><dt class="param">k</dt><dd class="cmt"><p>k-nearest neighbor.</p></dd><dt class="param">CIsomap</dt><dd class="cmt"><p>C-Isomap algorithm if true, otherwise standard algorithm.</p></dd></dl></div>
    </li><li name="smile.manifold.Operators#laplacian" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="laplacian(data:Array[Array[Double]],d:Int,k:Int,t:Double):smile.manifold.LaplacianEigenmap"></a><a id="laplacian(Array[Array[Double]],Int,Int,Double):LaplacianEigenmap"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#laplacian(data:Array[Array[Double]],d:Int,k:Int,t:Double):smile.manifold.LaplacianEigenmap" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">laplacian</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="d">d: <span class="extype" name="scala.Int">Int</span></span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="t">t: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">1</span></span>)</span><span class="result">: <span class="extype" name="smile.manifold.LaplacianEigenmap">LaplacianEigenmap</span></span>
      </span>
      
      <p class="shortcomment cmt">Laplacian Eigenmap.</p><div class="fullcomment"><div class="comment cmt"><p>Laplacian Eigenmap. Using the notion of the Laplacian of the nearest
neighbor adjacency graph, Laplacian Eigenmap compute a low dimensional
representation of the dataset that optimally preserves local neighborhood
information in a certain sense. The representation map generated by the
algorithm may be viewed as a discrete approximation to a continuous map
that naturally arises from the geometry of the manifold.</p><p>The locality preserving character of the Laplacian Eigenmap algorithm makes
it relatively insensitive to outliers and noise. It is also not prone to
&quot;short circuiting&quot; as only the local distances are used.</p><h6>References:</h6><ul><li>Mikhail Belkin and Partha Niyogi. Laplacian Eigenmaps and Spectral Techniques for Embedding and Clustering. NIPS, 2001.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">d</dt><dd class="cmt"><p>the dimension of the manifold.</p></dd><dt class="param">k</dt><dd class="cmt"><p>k-nearest neighbor.</p></dd><dt class="param">t</dt><dd class="cmt"><p>the smooth/width parameter of heat kernel e<sup>-||x-y||<sup>2</sup> / t</sup>.
         Non-positive value means discrete weights.</p></dd></dl></div>
    </li><li name="smile.manifold.Operators#lle" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lle(data:Array[Array[Double]],d:Int,k:Int):smile.manifold.LLE"></a><a id="lle(Array[Array[Double]],Int,Int):LLE"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#lle(data:Array[Array[Double]],d:Int,k:Int):smile.manifold.LLE" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lle</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="d">d: <span class="extype" name="scala.Int">Int</span></span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.manifold.LLE">LLE</span></span>
      </span>
      
      <p class="shortcomment cmt">Locally Linear Embedding.</p><div class="fullcomment"><div class="comment cmt"><p>Locally Linear Embedding. It has several advantages over Isomap, including
faster optimization when implemented to take advantage of sparse matrix
algorithms, and better results with many problems. LLE also begins by
finding a set of the nearest neighbors of each point. It then computes
a set of weights for each point that best describe the point as a linear
combination of its neighbors. Finally, it uses an eigenvector-based
optimization technique to find the low-dimensional embedding of points,
such that each point is still described with the same linear combination
of its neighbors. LLE tends to handle non-uniform sample densities poorly
because there is no fixed unit to prevent the weights from drifting as
various regions differ in sample densities.</p><h6>References:</h6><ul><li>Sam T. Roweis and Lawrence K. Saul. Nonlinear Dimensionality Reduction by Locally Linear Embedding. Science 290(5500):2323-2326, 2000.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">d</dt><dd class="cmt"><p>the dimension of the manifold.</p></dd><dt class="param">k</dt><dd class="cmt"><p>k-nearest neighbor.</p></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="smile.manifold.Operators#tsne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tsne(X:Array[Array[Double]],d:Int,perplexity:Double,eta:Double,iterations:Int):smile.manifold.TSNE"></a><a id="tsne(Array[Array[Double]],Int,Double,Double,Int):TSNE"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#tsne(X:Array[Array[Double]],d:Int,perplexity:Double,eta:Double,iterations:Int):smile.manifold.TSNE" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tsne</span><span class="params">(<span name="X">X: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="d">d: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">2</span></span>, <span name="perplexity">perplexity: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">20.0</span></span>, <span name="eta">eta: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">200.0</span></span>, <span name="iterations">iterations: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1000</span></span>)</span><span class="result">: <span class="extype" name="smile.manifold.TSNE">TSNE</span></span>
      </span>
      
      <p class="shortcomment cmt">t-distributed stochastic neighbor embedding.</p><div class="fullcomment"><div class="comment cmt"><p>t-distributed stochastic neighbor embedding. t-SNE is a nonlinear
dimensionality reduction technique that is particularly well suited
for embedding high-dimensional data into a space of two or three
dimensions, which can then be visualized in a scatter plot. Specifically,
it models each high-dimensional object by a two- or three-dimensional
point in such a way that similar objects are modeled by nearby points
and dissimilar objects are modeled by distant points.</p><h6>References:</h6><ul><li>L.J.P. van der Maaten. Accelerating t-SNE using Tree-Based Algorithms. Journal of Machine Learning Research 15(Oct):3221-3245, 2014.</li><li>L.J.P. van der Maaten and G.E. Hinton. Visualizing Non-Metric Similarities in Multiple Maps. Machine Learning 87(1):33-55, 2012.</li><li>L.J.P. van der Maaten. Learning a Parametric Embedding by Preserving Local Structure. In Proceedings of the Twelfth International Conference on Artificial Intelligence &amp; Statistics (AI-STATS), JMLR W&amp;CP 5:384-391, 2009.</li><li>L.J.P. van der Maaten and G.E. Hinton. Visualizing High-Dimensional Data Using t-SNE. Journal of Machine Learning Research 9(Nov):2579-2605, 2008.
</li></ul></div><dl class="paramcmts block"><dt class="param">X</dt><dd class="cmt"><p>input data. If X is a square matrix, it is assumed to be the squared distance/dissimilarity matrix.</p></dd><dt class="param">d</dt><dd class="cmt"><p>the dimension of the manifold.</p></dd><dt class="param">perplexity</dt><dd class="cmt"><p>the perplexity of the conditional distribution.</p></dd><dt class="param">eta</dt><dd class="cmt"><p>the learning rate.</p></dd><dt class="param">iterations</dt><dd class="cmt"><p>the number of iterations.</p></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.Predef.ArrowAssoc#→" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="→[B](y:B):(A,B)"></a><a id="→[B](B):(Operators,B)"></a>
      <span class="permalink">
      <a href="../../smile/manifold/Operators.html#→[B](y:B):(A,B)" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $u2192" class="implicit">→</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span class="extype" name="scala.Predef.ArrowAssoc.→.B">B</span></span>)</span><span class="result">: (<a href="" class="extype" name="smile.manifold.Operators">Operators</a>, <span class="extype" name="scala.Predef.ArrowAssoc.→.B">B</span>)</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to
            <span class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>] performed by method ArrowAssoc in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd></dl></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        <div class="conversion" name="scala.Predef.any2stringadd">
              <h3>Inherited by implicit conversion any2stringadd from
                <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to <span class="extype" name="scala.Predef.any2stringadd">any2stringadd</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>]
              </h3>
            </div><div class="conversion" name="scala.Predef.StringFormat">
              <h3>Inherited by implicit conversion StringFormat from
                <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to <span class="extype" name="scala.Predef.StringFormat">StringFormat</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>]
              </h3>
            </div><div class="conversion" name="scala.Predef.Ensuring">
              <h3>Inherited by implicit conversion Ensuring from
                <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>]
              </h3>
            </div><div class="conversion" name="scala.Predef.ArrowAssoc">
              <h3>Inherited by implicit conversion ArrowAssoc from
                <a href="" class="extype" name="smile.manifold.Operators">Operators</a> to <span class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</span>[<a href="" class="extype" name="smile.manifold.Operators">Operators</a>]
              </h3>
            </div>
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
